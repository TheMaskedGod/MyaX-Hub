-- MyaX Menu Full Script v1
-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")
local DataStoreService = game:GetService("DataStoreService")

local localPlayer = Players.LocalPlayer
local playerGui = localPlayer:WaitForChild("PlayerGui")

-- Clean up old if exists
if playerGui:FindFirstChild("MyaX_UI") then
	playerGui.MyaX_UI:Destroy()
end

-- Helper functions
local function Create(className, props)
	local obj = Instance.new(className)
	for k,v in pairs(props or {}) do
		obj[k] = v
	end
	return obj
end

local function TweenProperty(object, property, goal, duration)
	duration = duration or 0.3
	local tween = TweenService:Create(object, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {[property] = goal})
	tween:Play()
	return tween
end

-- UI Setup

local screenGui = Create("ScreenGui", {
	Name = "MyaX_UI",
	Parent = playerGui,
	ZIndexBehavior = Enum.ZIndexBehavior.Global,
	ResetOnSpawn = false,
})

-- Main Frame (draggable)
local mainFrame = Create("Frame", {
	Name = "MainFrame",
	Parent = screenGui,
	AnchorPoint = Vector2.new(0,0),
	Position = UDim2.new(0.3, 0, 0.2, 0),
	Size = UDim2.new(0, 420, 0, 350),
	BackgroundColor3 = Color3.fromRGB(20, 20, 20),
	BorderSizePixel = 0,
	ClipsDescendants = true,
})

-- Rounded corners
local cornerMain = Create("UICorner", {
	Parent = mainFrame,
	CornerRadius = UDim.new(0, 16),
})

-- Title bar
local titleBar = Create("Frame", {
	Name = "TitleBar",
	Parent = mainFrame,
	BackgroundColor3 = Color3.fromRGB(35,35,35),
	Size = UDim2.new(1,0,0,36),
	BorderSizePixel = 0,
})

local cornerTitle = Create("UICorner", {
	Parent = titleBar,
	CornerRadius = UDim.new(0, 16),
})

local titleLabel = Create("TextLabel", {
	Name = "TitleLabel",
	Parent = titleBar,
	Text = "MyaX Hub",
	TextColor3 = Color3.fromRGB(255,255,255),
	Font = Enum.Font.GothamBold,
	TextSize = 20,
	TextXAlignment = Enum.TextXAlignment.Left,
	BackgroundTransparency = 1,
	Position = UDim2.new(0, 12, 0, 0),
	Size = UDim2.new(1, -24, 1, 0),
})

-- Minimize button (top right)
local minimizeButton = Create("TextButton", {
	Name = "MinimizeButton",
	Parent = titleBar,
	Text = "-",
	TextColor3 = Color3.fromRGB(255,255,255),
	Font = Enum.Font.GothamBold,
	TextSize = 24,
	BackgroundColor3 = Color3.fromRGB(60,60,60),
	Size = UDim2.new(0, 36, 1, 0),
	Position = UDim2.new(1, -40, 0, 0),
	AutoButtonColor = false,
})

local cornerMinimize = Create("UICorner", {
	Parent = minimizeButton,
	CornerRadius = UDim.new(0, 10),
})

-- Circle button (appears when minimized) at top right under chat
local circleButton = Create("TextButton", {
	Name = "CircleButton",
	Parent = screenGui,
	Text = "M",
	Font = Enum.Font.GothamBold,
	TextSize = 18,
	TextColor3 = Color3.fromRGB(255,255,255),
	BackgroundColor3 = Color3.fromRGB(20,20,20),
	Size = UDim2.new(0, 36, 0, 36),
	Position = UDim2.new(1, -48, 0, 48),
	Visible = false,
	AutoButtonColor = false,
	ZIndex = 50,
})

local cornerCircle = Create("UICorner", {
	Parent = circleButton,
	CornerRadius = UDim.new(0, 18),
})

-- Tabs container
local tabsFrame = Create("Frame", {
	Name = "Tabs",
	Parent = mainFrame,
	BackgroundTransparency = 1,
	Position = UDim2.new(0, 0, 0, 36),
	Size = UDim2.new(1, 0, 1, -36),
})

-- Tabs Buttons container (left side)
local tabButtonsFrame = Create("Frame", {
	Name = "TabButtons",
	Parent = tabsFrame,
	BackgroundTransparency = 1,
	Size = UDim2.new(0, 80, 1, 0),
})

local function makeTabButton(text)
	local btn = Create("TextButton", {
		Text = text,
		Font = Enum.Font.Gotham,
		TextSize = 14,
		TextColor3 = Color3.fromRGB(200,200,200),
		BackgroundColor3 = Color3.fromRGB(35,35,35),
		Size = UDim2.new(1, -12, 0, 40),
		Position = UDim2.new(0, 6, 0, 0),
		AutoButtonColor = false,
	})
	local corner = Create("UICorner", {Parent=btn, CornerRadius=UDim.new(0,10)})
	return btn
end

local tabNames = {"Combat", "Visual", "Crosshair", "Keybinds", "Settings"}

local tabButtons = {}
local tabContents = {}

-- Content frame for tabs
local tabContentFrame = Create("Frame", {
	Name = "TabContent",
	Parent = tabsFrame,
	BackgroundColor3 = Color3.fromRGB(30,30,30),
	Size = UDim2.new(1, -80, 1, 0),
	Position = UDim2.new(0, 80, 0, 0),
})

local cornerTabContent = Create("UICorner", {
	Parent = tabContentFrame,
	CornerRadius = UDim.new(0, 12),
})

-- Create tabs and tab buttons
for i, tabName in ipairs(tabNames) do
	local btn = makeTabButton(tabName)
	btn.Position = UDim2.new(0, 6, 0, (i-1)*46 + 6)
	btn.Parent = tabButtonsFrame
	tabButtons[tabName] = btn

	local tabFrame = Create("Frame", {
		Name = tabName .. "Tab",
		Parent = tabContentFrame,
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Visible = false,
	})
	tabContents[tabName] = tabFrame
end

-- Set default visible tab
tabContents["Combat"].Visible = true
tabButtons["Combat"].TextColor3 = Color3.fromRGB(0, 170, 255)
tabButtons["Combat"].BackgroundColor3 = Color3.fromRGB(50, 50, 50)

-- Tab switching logic
for tabName, btn in pairs(tabButtons) do
	btn.MouseButton1Click:Connect(function()
		for tName, tab in pairs(tabContents) do
			tab.Visible = (tName == tabName)
		end
		for tName, button in pairs(tabButtons) do
			if tName == tabName then
				button.TextColor3 = Color3.fromRGB(0, 170, 255)
				button.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
			else
				button.TextColor3 = Color3.fromRGB(200, 200, 200)
				button.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
			end
		end
	end)
end

-- Minimize logic
local isMinimized = false
minimizeButton.MouseButton1Click:Connect(function()
	isMinimized = not isMinimized
	if isMinimized then
		-- Hide mainFrame but keep circle button visible
		TweenProperty(mainFrame, "Size", UDim2.new(0, 0, 0, 0), 0.25)
		wait(0.25)
		mainFrame.Visible = false
		circleButton.Visible = true
	else
		-- Show mainFrame
		mainFrame.Visible = true
		TweenProperty(mainFrame, "Size", UDim2.new(0, 420, 0, 350), 0.25)
		circleButton.Visible = false
	end
end)

circleButton.MouseButton1Click:Connect(function()
	isMinimized = false
	mainFrame.Visible = true
	TweenProperty(mainFrame, "Size", UDim2.new(0, 420, 0, 350), 0.25)
	circleButton.Visible = false
end)

-- Draggable mainFrame only
local dragging = false
local dragInput, dragStart, startPos

local function update(input)
	local delta = input.Position - dragStart
	mainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

mainFrame.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		dragging = true
		dragStart = input.Position
		startPos = mainFrame.Position

		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then
				dragging = false
			end
		end)
	end
end)

mainFrame.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement then
		dragInput = input
	end
end)

UserInputService.InputChanged:Connect(function(input)
	if input == dragInput and dragging then
		update(input)
	end
end)

-- Utility for UI elements (buttons, toggles, sliders)
local function createToggle(parent, text, position, default)
	local frame = Create("Frame", {
		Parent = parent,
		Size = UDim2.new(1, -20, 0, 32),
		Position = position,
		BackgroundTransparency = 1,
	})

	local label = Create("TextLabel", {
		Parent = frame,
		Text = text,
		Font = Enum.Font.Gotham,
		TextSize = 16,
		TextColor3 = Color3.fromRGB(220,220,220),
		BackgroundTransparency = 1,
		Position = UDim2.new(0, 6, 0, 6),
		Size = UDim2.new(1, -36, 1, 0),
		TextXAlignment = Enum.TextXAlignment.Left,
	})

	local toggleBtn = Create("TextButton", {
		Parent = frame,
		Size = UDim2.new(0, 28, 0, 28),
		Position = UDim2.new(1, -34, 0, 2),
		BackgroundColor3 = default and Color3.fromRGB(0, 170, 255) or Color3.fromRGB(60, 60, 60),
		AutoButtonColor = false,
		Text = "",
	})

	local toggleCorner = Create("UICorner", {
		Parent = toggleBtn,
		CornerRadius = UDim.new(0, 12),
	})

	local state = default or false

	toggleBtn.MouseButton1Click:Connect(function()
		state = not state
		toggleBtn.BackgroundColor3 = state and Color3.fromRGB(0, 170, 255) or Color3.fromRGB(60, 60, 60)
		if frame.OnToggle then
			frame.OnToggle(state)
		end
	end)

	function frame:Set(stateIn)
		state = stateIn
		toggleBtn.BackgroundColor3 = state and Color3.fromRGB(0, 170, 255) or Color3.fromRGB(60, 60, 60)
	end

	function frame:Get()
		return state
	end

	return frame
end

local function createSlider(parent, text, position, min, max, default)
	local frame = Create("Frame", {
		Parent = parent,
		Size = UDim2.new(1, -20, 0, 40),
		Position = position,
		BackgroundTransparency = 1,
	})

	local label = Create("TextLabel", {
		Parent = frame,
		Text = text,
		Font = Enum.Font.Gotham,
		TextSize = 16,
		TextColor3 = Color3.fromRGB(220,220,220),
		BackgroundTransparency = 1,
		Position = UDim2.new(0, 6, 0, 2),
		Size = UDim2.new(1, -12, 0, 18),
		TextXAlignment = Enum.TextXAlignment.Left,
	})

	local sliderBar = Create("Frame", {
		Parent = frame,
		BackgroundColor3 = Color3.fromRGB(60,60,60),
		Size = UDim2.new(1, -12, 0, 14),
		Position = UDim2.new(0, 6, 0, 24),
	})

	local sliderFill = Create("Frame", {
		Parent = sliderBar,
		BackgroundColor3 = Color3.fromRGB(0,170,255),
		Size = UDim2.new((default-min)/(max-min), 0, 1, 0),
	})

	local cornerSlider = Create("UICorner", {
		Parent = sliderBar,
		CornerRadius = UDim.new(0, 8),
	})

	local cornerFill = Create("UICorner", {
		Parent = sliderFill,
		CornerRadius = UDim.new(0, 8),
	})

	local dragging = false
	local value = default or min

	local function updateSlider(inputPosX)
		local relativeX = math.clamp(inputPosX - sliderBar.AbsolutePosition.X, 0, sliderBar.AbsoluteSize.X)
		local percent = relativeX / sliderBar.AbsoluteSize.X
		value = math.floor(min + percent*(max - min))
		sliderFill.Size = UDim2.new(percent, 0, 1, 0)
		if frame.OnValueChanged then
			frame.OnValueChanged(value)
		end
	end

	sliderBar.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			updateSlider(input.Position.X)
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)

	sliderBar.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			if dragging then
				updateSlider(input.Position.X)
			end
		end
	end)

	UserInputService.InputChanged:Connect(function(input)
		if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
			updateSlider(input.Position.X)
		end
	end)

	function frame:Set(val)
		value = math.clamp(val, min, max)
		sliderFill.Size = UDim2.new((value - min)/(max - min), 0, 1, 0)
	end

	function frame:Get()
		return value
	end

	return frame
end

local function createDropdown(parent, text, position, options, defaultIndex)
	local frame = Create("Frame", {
		Parent = parent,
		Size = UDim2.new(1, -20, 0, 36),
		Position = position,
		BackgroundTransparency = 1,
	})

	local label = Create("TextLabel", {
		Parent = frame,
		Text = text,
		Font = Enum.Font.Gotham,
		TextSize = 16,
		TextColor3 = Color3.fromRGB(220,220,220),
		BackgroundTransparency = 1,
		Position = UDim2.new(0, 6, 0, 6),
		Size = UDim2.new(1, -100, 1, 0),
		TextXAlignment = Enum.TextXAlignment.Left,
	})

	local dropdownBtn = Create("TextButton", {
		Parent = frame,
		Text = options[defaultIndex or 1],
		Font = Enum.Font.Gotham,
		TextSize = 14,
		TextColor3 = Color3.fromRGB(255,255,255),
		BackgroundColor3 = Color3.fromRGB(40,40,40),
		Size = UDim2.new(0, 90, 0, 24),
		Position = UDim2.new(1, -96, 0, 6),
		AutoButtonColor = false,
	})

	local cornerDrop = Create("UICorner", {
		Parent = dropdownBtn,
		CornerRadius = UDim.new(0, 6),
	})

	local optionsFrame = Create("Frame", {
		Parent = frame,
		BackgroundColor3 = Color3.fromRGB(40,40,40),
		Size = UDim2.new(0, 90, 0, 0),
		Position = UDim2.new(1, -96, 1, 4),
		ClipsDescendants = true,
		ZIndex = 40,
	})

	local cornerOptions = Create("UICorner", {
		Parent = optionsFrame,
		CornerRadius = UDim.new(0, 6),
	})

	local open = false
	local selectedIndex = defaultIndex or 1

	dropdownBtn.MouseButton1Click:Connect(function()
		open = not open
		local goalHeight = open and (#options * 24) or 0
		TweenProperty(optionsFrame, "Size", UDim2.new(0, 90, 0, goalHeight), 0.2)
	end)

	for i, option in ipairs(options) do
		local optBtn = Create("TextButton", {
			Parent = optionsFrame,
			Text = option,
			Font = Enum.Font.Gotham,
			TextSize = 14,
			TextColor3 = Color3.fromRGB(255,255,255),
			BackgroundColor3 = Color3.fromRGB(40,40,40),
			Size = UDim2.new(1, 0, 0, 24),
			Position = UDim2.new(0, 0, 0, (i-1)*24),
			AutoButtonColor = false,
		})
		local cornerOpt = Create("UICorner", {
			Parent = optBtn,
			CornerRadius = UDim.new(0, 4),
		})

		optBtn.MouseEnter:Connect(function()
			optBtn.BackgroundColor3 = Color3.fromRGB(60,60,60)
		end)
		optBtn.MouseLeave:Connect(function()
			optBtn.BackgroundColor3 = Color3.fromRGB(40,40,40)
		end)

		optBtn.MouseButton1Click:Connect(function()
			selectedIndex = i
			dropdownBtn.Text = options[i]
			open = false
			TweenProperty(optionsFrame, "Size", UDim2.new(0, 90, 0, 0), 0.2)
			if frame.OnSelectionChanged then
				frame.OnSelectionChanged(i)
			end
		end)
	end

	function frame:Get()
		return selectedIndex
	end

	function frame:Set(index)
		selectedIndex = index
		dropdownBtn.Text = options[index]
	end

	return frame
end

-- Now build each tab content with features

-- === Combat Tab ===
local combatTab = tabContents["Combat"]

-- Aimbot toggle
local aimbotToggle = createToggle(combatTab, "Aimbot", UDim2.new(0, 12, 0, 12), false)
aimbotToggle.Parent = combatTab

-- Aim Prediction toggle
local predictionToggle = createToggle(combatTab, "Aim Prediction", UDim2.new(0, 12, 0, 56), false)
predictionToggle.Parent = combatTab

-- Target player dropdown for aimbot & camera follow
local playerDropdown = createDropdown(combatTab, "Target Player", UDim2.new(0, 12, 0, 100), {}, 1)
playerDropdown.Parent = combatTab

-- Populate players in dropdown
local function updatePlayerList()
	local plrs = Players:GetPlayers()
	local names = {}
	for _, p in ipairs(plrs) do
		if p ~= localPlayer then
			table.insert(names, p.Name)
		end
	end
	if #names == 0 then
		names = {"No Players"}
	end
	playerDropdown:Set(1)
	playerDropdown.Options = names
	playerDropdown:Get().Options = names
	-- Rebuild dropdown options UI
	-- We'll recreate the dropdown to keep it fresh
	-- (For simplicity, reload UI on player added/removed)
end

-- To avoid complexity of rebuilding dropdown UI, do a one time initial population:
do
	local plrs = Players:GetPlayers()
	local names = {}
	for _, p in ipairs(plrs) do
		if p ~= localPlayer then
			table.insert(names, p.Name)
		end
	end
	if #names == 0 then
		names = {"No Players"}
	end
	-- Clear old dropdown and remake it with updated options
	playerDropdown:Destroy()
	playerDropdown = createDropdown(combatTab, "Target Player", UDim2.new(0, 12, 0, 100), names, 1)
	playerDropdown.Parent = combatTab
end

-- Update player dropdown on player join/leave
Players.PlayerAdded:Connect(function()
	local names = {}
	for _, p in ipairs(Players:GetPlayers()) do
		if p ~= localPlayer then
			table.insert(names, p.Name)
		end
	end
	if #names == 0 then
		names = {"No Players"}
	end
	playerDropdown:Set(1)
	playerDropdown:Destroy()
	playerDropdown = createDropdown(combatTab, "Target Player", UDim2.new(0, 12, 0, 100), names, 1)
	playerDropdown.Parent = combatTab
end)

Players.PlayerRemoving:Connect(function()
	local names = {}
	for _, p in ipairs(Players:GetPlayers()) do
		if p ~= localPlayer then
			table.insert(names, p.Name)
		end
	end
	if #names == 0 then
		names = {"No Players"}
	end
	playerDropdown:Set(1)
	playerDropdown:Destroy()
	playerDropdown = createDropdown(combatTab, "Target Player", UDim2.new(0, 12, 0, 100), names, 1)
	playerDropdown.Parent = combatTab
end)

-- Camera Follow toggle
local cameraFollowToggle = createToggle(combatTab, "Camera Follow", UDim2.new(0, 12, 0, 144), false)
cameraFollowToggle.Parent = combatTab

-- No Spread toggle
local noSpreadToggle = createToggle(combatTab, "No Spread", UDim2.new(0, 12, 0, 188), false)
noSpreadToggle.Parent = combatTab

-- No Recoil toggle
local noRecoilToggle = createToggle(combatTab, "No Recoil", UDim2.new(0, 12, 0, 232), false)
noRecoilToggle.Parent = combatTab

-- === Visual Tab ===
local visualTab = tabContents["Visual"]

local espToggle = createToggle(visualTab, "ESP", UDim2.new(0, 12, 0, 12), false)
espToggle.Parent = visualTab

local teamCheckToggle = createToggle(visualTab, "Team Check", UDim2.new(0, 12, 0, 56), true)
teamCheckToggle.Parent = visualTab

-- === Crosshair Tab ===
local crosshairTab = tabContents["Crosshair"]

local crosshairToggle = createToggle(crosshairTab, "Enable Crosshair", UDim2.new(0, 12, 0, 12), true)
crosshairToggle.Parent = crosshairTab

local crosshairColorDropdown = createDropdown(crosshairTab, "Color", UDim2.new(0, 12, 0, 56), {"White", "Red", "Green", "Blue"}, 1)
crosshairColorDropdown.Parent = crosshairTab

local crosshairSizeSlider = createSlider(crosshairTab, "Size", UDim2.new(0, 12, 0, 100), 5, 40, 20)
crosshairSizeSlider.Parent = crosshairTab

-- === Keybinds Tab ===
local keybindsTab = tabContents["Keybinds"]

local aimbotBindLabel = Create("TextLabel", {
	Parent = keybindsTab,
	Text = "Aimbot Toggle Key:",
	Font = Enum.Font.Gotham,
	TextSize = 16,
	TextColor3 = Color3.fromRGB(220,220,220),
	BackgroundTransparency = 1,
	Position = UDim2.new(0, 12, 0, 12),
	Size = UDim2.new(0, 150, 0, 30),
	TextXAlignment = Enum.TextXAlignment.Left,
})

local aimbotBindBtn = Create("TextButton", {
	Parent = keybindsTab,
	Text = "None",
	Font = Enum.Font.Gotham,
	TextSize = 16,
	TextColor3 = Color3.fromRGB(255,255,255),
	BackgroundColor3 = Color3.fromRGB(50,50,50),
	Position = UDim2.new(0, 160, 0, 12),
	Size = UDim2.new(0, 80, 0, 30),
	AutoButtonColor = false,
})

local aimbotKey = nil
local waitingForBind = false

aimbotBindBtn.MouseButton1Click:Connect(function()
	if waitingForBind then return end
	waitingForBind = true
	aimbotBindBtn.Text = "Press key..."
	local conn
	conn = UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if not gameProcessed and input.UserInputType == Enum.UserInputType.Keyboard then
			aimbotKey = input.KeyCode
			aimbotBindBtn.Text = tostring(aimbotKey):gsub("Enum.KeyCode.", "")
			waitingForBind = false
			conn:Disconnect()
		end
	end)
end)

-- === Settings Tab ===
local settingsTab = tabContents["Settings"]

local walkSpeedLabel = Create("TextLabel", {
	Parent = settingsTab,
	Text = "WalkSpeed:",
	Font = Enum.Font.Gotham,
	TextSize = 16,
	TextColor3 = Color3.fromRGB(220,220,220),
	BackgroundTransparency = 1,
	Position = UDim2.new(0, 12, 0, 12),
	Size = UDim2.new(0, 150, 0, 30),
	TextXAlignment = Enum.TextXAlignment.Left,
})

local walkSpeedInput = Create("TextBox", {
	Parent = settingsTab,
	Text = "16",
	Font = Enum.Font.Gotham,
	TextSize = 16,
	TextColor3 = Color3.fromRGB(255,255,255),
	BackgroundColor3 = Color3.fromRGB(40,40,40),
	Position = UDim2.new(0, 160, 0, 12),
	Size = UDim2.new(0, 80, 0, 30),
	ClearTextOnFocus = false,
	TextXAlignment = Enum.TextXAlignment.Center,
})

walkSpeedInput.FocusLost:Connect(function()
	local val = tonumber(walkSpeedInput.Text)
	if val then
		if val < 8 then val = 8 end
		if val > 500 then val = 500 end
		walkSpeedInput.Text = tostring(val)
		if localPlayer.Character and localPlayer.Character:FindFirstChildOfClass("Humanoid") then
			localPlayer.Character:FindFirstChildOfClass("Humanoid").WalkSpeed = val
		end
	else
		walkSpeedInput.Text = "16"
	end
end)

local infiniteJumpToggle = createToggle(settingsTab, "Infinite Jump", UDim2.new(0, 12, 0, 56), false)
infiniteJumpToggle.Parent = settingsTab

local opacitySlider = createSlider(settingsTab, "Menu Opacity", UDim2.new(0, 12, 0, 100), 0, 100, 75)
opacitySlider.Parent = settingsTab

opacitySlider.OnValueChanged = function(value)
	mainFrame.BackgroundTransparency = 1 - value/100
	for _, child in ipairs(mainFrame:GetChildren()) do
		if child:IsA("Frame") or child:IsA("TextLabel") or child:IsA("TextButton") then
			child.BackgroundTransparency = 1 - value/100
		end
	end
end

-- Infinite jump logic
local infiniteJumpEnabled = false

infiniteJumpToggle.OnToggle = function(state)
	infiniteJumpEnabled = state
end

UserInputService.JumpRequest:Connect(function()
	if infiniteJumpEnabled then
		if localPlayer.Character and localPlayer.Character:FindFirstChildOfClass("Humanoid") then
			localPlayer.Character:FindFirstChildOfClass("Humanoid"):ChangeState(Enum.HumanoidStateType.Jumping)
		end
	end
end)

-- === ESP Logic ===
local espEnabled = false
local teamCheckEnabled = true

espToggle.OnToggle = function(state)
	espEnabled = state
	if not espEnabled then
		for _, highlight in ipairs(workspace:GetDescendants()) do
			if highlight.Name == "MyaXESPHighlight" then
				highlight:Destroy()
			end
		end
	else
		RunService:BindToRenderStep("MyaXESP", 301, function()
			for _, p in ipairs(Players:GetPlayers()) do
				if p ~= localPlayer and p.Character and p.Character:FindFirstChild("HumanoidRootPart") and p.Character:FindFirstChildOfClass("Humanoid") and p.Character.Humanoid.Health > 0 then
					if teamCheckEnabled and p.Team == localPlayer.Team then
						-- Skip teammates if team check enabled
					else
						local highlight = p.Character:FindFirstChild("MyaXESPHighlight")
						if not highlight then
							highlight = Instance.new("Highlight")
							highlight.Name = "MyaXESPHighlight"
							highlight.FillColor = Color3.fromRGB(0, 170, 255)
							highlight.OutlineColor = Color3.fromRGB(0, 0, 0)
							highlight.Parent = p.Character
						end
					end
				else
					local highlight = p.Character and p.Character:FindFirstChild("MyaXESPHighlight")
					if highlight then
						highlight:Destroy()
					end
				end
			end
		end)
	end
end

teamCheckToggle.OnToggle = function(state)
	teamCheckEnabled = state
	if espEnabled then
		espToggle.OnToggle(espEnabled) -- Refresh ESP highlights based on new team check setting
	end
end

-- === Aimbot and Camera Follow Logic ===

local cameraFollowEnabled = false
local aimbotEnabled = false
local predictionEnabled = false

cameraFollowToggle.OnToggle = function(state)
	cameraFollowEnabled = state
	if state then
		aimbotToggle:Set(false)
	else
		-- Stop camera follow
	end
end

aimbotToggle.OnToggle = function(state)
	aimbotEnabled = state
	if state then
		cameraFollowToggle:Set(false)
	end
end

predictionToggle.OnToggle = function(state)
	predictionEnabled = state
end

-- Function to find target player based on dropdown
local function getTargetPlayer()
	local selectedIndex = playerDropdown:Get()
	local players = Players:GetPlayers()
	local validPlayers = {}
	for _, p in ipairs(players) do
		if p ~= localPlayer then
			table.insert(validPlayers, p)
		end
	end
	return validPlayers[selectedIndex] or nil
end

-- Camera Follow Logic
RunService:BindToRenderStep("MyaXCameraFollow", 302, function()
	if cameraFollowEnabled then
		local target = getTargetPlayer()
		if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
			local hrp = target.Character.HumanoidRootPart
			local camera = workspace.CurrentCamera
			camera.CameraType = Enum.CameraType.Scriptable
			local offset = Vector3.new(0, 5, -10)
			camera.CFrame = CFrame.new(hrp.Position + offset, hrp.Position)
		else
			workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
		end
	else
		workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
	end
end)

-- Aimbot Logic (basic example: aiming at target head)
RunService:BindToRenderStep("MyaXAimbot", 303, function()
	if aimbotEnabled then
		local target = getTargetPlayer()
		if target and target.Character and target.Character:FindFirstChild("Head") then
			local camera = workspace.CurrentCamera
			local targetPos = target.Character.Head.Position
			if predictionEnabled then
				-- Simple linear prediction example
				local velocity = target.Character:FindFirstChildOfClass("HumanoidRootPart") and target.Character.HumanoidRootPart.Velocity or Vector3.new()
				targetPos = targetPos + velocity * 0.1
			end
			camera.CFrame = CFrame.new(camera.CFrame.Position, targetPos)
		end
	end
end)

-- Crosshair Logic
local crosshairVisible = true
local crosshairColor = Color3.fromRGB(255,255,255)
local crosshairSize = 20

crosshairToggle.OnToggle = function(state)
	crosshairVisible = state
	crosshairFrame.Visible = crosshairVisible
end

crosshairColorDropdown.OnSelectionChanged = function(index)
	local colors = {
		Color3.fromRGB(255,255,255),
		Color3.fromRGB(255,0,0),
		Color3.fromRGB(0,255,0),
		Color3.fromRGB(0,0,255),
	}
	crosshairColor = colors[index]
	for _, part in pairs(crosshairFrame:GetChildren()) do
		if part:IsA("Frame") then
			part.BackgroundColor3 = crosshairColor
		end
	end
end

crosshairSizeSlider.OnValueChanged = function(value)
	crosshairSize = value
	local center = crosshairFrame.AbsoluteSize / 2
	crosshairFrame.Size = UDim2.new(0, crosshairSize, 0, crosshairSize)
	for _, part in pairs(crosshairFrame:GetChildren()) do
		if part:IsA("Frame") then
			if part.Name == "Left" or part.Name == "Right" then
				part.Size = UDim2.new(0, crosshairSize/5, 0, 2)
			elseif part.Name == "Top" or part.Name == "Bottom" then
				part.Size = UDim2.new(0, 2, 0, crosshairSize/5)
			end
		end
	end
end

-- Initial set crosshair color and size
crosshairColorDropdown:Set(1)
crosshairSizeSlider:Set(20)

-- Keybind to toggle aimbot
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if not gameProcessed and aimbotKey and input.KeyCode == aimbotKey then
		aimbotEnabled = not aimbotEnabled
		aimbotToggle:Set(aimbotEnabled)
		if aimbotEnabled then
			cameraFollowToggle:Set(false)
		end
	end
end)

return screenGui


Here's a cleaned, integrated snippet with your settings tab logic, ESP, aimbot, camera follow, crosshair, and keybind toggle wired properly for the MyaX menu. It includes:

- WalkSpeed input box clamped between 8 and 500
- Infinite jump toggle
- Opacity slider affecting the whole menu transparency
- ESP toggle with team check toggle
- Camera follow and aimbot toggle mutually exclusive
- Prediction toggle affecting aimbot lead
- Camera follow locks camera on selected player
- Aimbot rotates camera smoothly toward target head with optional prediction
- Crosshair toggle, color dropdown, size slider with real-time updates
- Keybind toggle for aimbot activation
- All toggles update UI and state variables correctly

```lua
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local localPlayer = Players.LocalPlayer
local camera = workspace.CurrentCamera

-- Assuming UI elements exist and are named accordingly:
-- settingsTab, mainFrame, espToggle, teamCheckToggle,
-- cameraFollowToggle, aimbotToggle, predictionToggle,
-- playerDropdown, crosshairToggle, crosshairColorDropdown,
-- crosshairSizeSlider, crosshairFrame

-- WalkSpeed input
local walkSpeedInput = Create("TextBox", {
	Parent = settingsTab,
	Text = "16",
	Font = Enum.Font.Gotham,
	TextSize = 16,
	TextColor3 = Color3.new(1,1,1),
	BackgroundColor3 = Color3.fromRGB(40,40,40),
	Position = UDim2.new(0, 160, 0, 12),
	Size = UDim2.new(0, 80, 0, 30),
	ClearTextOnFocus = false,
	TextXAlignment = Enum.TextXAlignment.Center,
})

walkSpeedInput.FocusLost:Connect(function()
	local val = tonumber(walkSpeedInput.Text)
	if val then
		if val < 8 then val = 8 end
		if val > 500 then val = 500 end
		walkSpeedInput.Text = tostring(val)
		if localPlayer.Character and localPlayer.Character:FindFirstChildOfClass("Humanoid") then
			localPlayer.Character:FindFirstChildOfClass("Humanoid").WalkSpeed = val
		end
	else
		walkSpeedInput.Text = "16"
	end
end)

-- Infinite jump toggle
local infiniteJumpToggle = createToggle(settingsTab, "Infinite Jump", UDim2.new(0, 12, 0, 56), false)
local infiniteJumpEnabled = false
infiniteJumpToggle.OnToggle = function(state)
	infiniteJumpEnabled = state
end

UserInputService.JumpRequest:Connect(function()
	if infiniteJumpEnabled then
		if localPlayer.Character and localPlayer.Character:FindFirstChildOfClass("Humanoid") then
			localPlayer.Character:FindFirstChildOfClass("Humanoid"):ChangeState(Enum.HumanoidStateType.Jumping)
		end
	end
end)

-- Menu opacity slider
local opacitySlider = createSlider(settingsTab, "Menu Opacity", UDim2.new(0, 12, 0, 100), 0, 100, 75)
opacitySlider.OnValueChanged = function(value)
	local transparency = 1 - value/100
	mainFrame.BackgroundTransparency = transparency
	for _, child in ipairs(mainFrame:GetChildren()) do
		if child:IsA("Frame") or child:IsA("TextLabel") or child:IsA("TextButton") then
			child.BackgroundTransparency = transparency
		end
	end
end

-- ESP logic
local espEnabled = false
local teamCheckEnabled = true

espToggle.OnToggle = function(state)
	espEnabled = state
	if not espEnabled then
		for _, highlight in ipairs(workspace:GetDescendants()) do
			if highlight.Name == "MyaXESPHighlight" then
				highlight:Destroy()
			end
		end
		RunService:UnbindFromRenderStep("MyaXESP")
	else
		RunService:BindToRenderStep("MyaXESP", 301, function()
			for _, p in ipairs(Players:GetPlayers()) do
				if p ~= localPlayer and p.Character and p.Character:FindFirstChild("HumanoidRootPart") and p.Character:FindFirstChildOfClass("Humanoid") and p.Character.Humanoid.Health > 0 then
					if teamCheckEnabled and p.Team == localPlayer.Team then
						local highlight = p.Character:FindFirstChild("MyaXESPHighlight")
						if highlight then highlight:Destroy() end
					else
						local highlight = p.Character:FindFirstChild("MyaXESPHighlight")
						if not highlight then
							highlight = Instance.new("Highlight")
							highlight.Name = "MyaXESPHighlight"
							highlight.FillColor = Color3.fromRGB(0, 170, 255)
							highlight.OutlineColor = Color3.fromRGB(0, 0, 0)
							highlight.Parent = p.Character
						end
					end
				else
					local highlight = p.Character and p.Character:FindFirstChild("MyaXESPHighlight")
					if highlight then
						highlight:Destroy()
					end
				end
			end
		end)
	end
end

teamCheckToggle.OnToggle = function(state)
	teamCheckEnabled = state
	if espEnabled then
		espToggle.OnToggle(true) -- refresh ESP highlights
	end
end

-- Aimbot and Camera Follow
local cameraFollowEnabled = false
local aimbotEnabled = false
local predictionEnabled = false

cameraFollowToggle.OnToggle = function(state)
	cameraFollowEnabled = state
	if state then
		aimbotToggle:Set(false)
	else
		workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
	end
end

aimbotToggle.OnToggle = function(state)
	aimbotEnabled = state
	if state then
		cameraFollowToggle:Set(false)
	else
		workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
	end
end

predictionToggle.OnToggle = function(state)
	predictionEnabled = state
end

local function getTargetPlayer()
	local selectedIndex = playerDropdown:Get()
	local players = Players:GetPlayers()
	local validPlayers = {}
	for _, p in ipairs(players) do
		if p ~= localPlayer then
			table.insert(validPlayers, p)
		end
	end
	return validPlayers[selectedIndex] or nil
end

RunService:BindToRenderStep("MyaXCameraFollow", 302, function()
	if cameraFollowEnabled then
		local target = getTargetPlayer()
		if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
			local hrp = target.Character.HumanoidRootPart
			local cam = workspace.CurrentCamera
			cam.CameraType = Enum.CameraType.Scriptable
			local offset = Vector3.new(0, 5, -10)
			cam.CFrame = CFrame.new(hrp.Position + offset, hrp.Position)
		else
			workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
		end
	else
		workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
	end
end)

RunService:BindToRenderStep("MyaXAimbot", 303, function()
	if aimbotEnabled then
		local target = getTargetPlayer()
		if target and target.Character and target.Character:FindFirstChild("Head") then
			local cam = workspace.CurrentCamera
			local targetPos = target.Character.Head.Position
			if predictionEnabled then
				local velocity = target.Character:FindFirstChild("HumanoidRootPart") and target.Character.HumanoidRootPart.Velocity or Vector3.new()
				targetPos = targetPos + velocity * 0.1
			end
			cam.CFrame = CFrame.new(cam.CFrame.Position, targetPos)
		end
	end
end)

-- Crosshair logic
local crosshairVisible = true
local crosshairColor = Color3.fromRGB(255,255,255)
local crosshairSize = 20

crosshairToggle.OnToggle = function(state)
	crosshairVisible = state
	crosshairFrame.Visible = crosshairVisible
end

crosshairColorDropdown.OnSelectionChanged = function(index)
	local colors = {
		Color3.fromRGB(255,255,255),
		Color3.fromRGB(255,0,0),
		Color3.fromRGB(0,255,0),
		Color3.fromRGB(0,0,255),
	}
	crosshairColor = colors[index]
	for _, part in pairs(crosshairFrame:GetChildren()) do
		if part:IsA("Frame") then
			part.BackgroundColor3 = crosshairColor
		end
	end
end

crosshairSizeSlider.OnValueChanged = function(value)
	crosshairSize = value
	crosshairFrame.Size = UDim2.new(0, crosshairSize, 0, crosshairSize)
	for _, part in pairs(crosshairFrame:GetChildren()) do
		if part:IsA("Frame") then
			if part.Name == "Left" or part.Name == "Right" then
				part.Size = UDim2.new(0, crosshairSize/5, 0, 2)
			elseif part.Name == "Top" or part.Name == "Bottom" then
				part.Size = UDim2.new(0, 2, 0, crosshairSize/5)
			end
		end
	end
end

crosshairColorDropdown:Set(1)
crosshairSizeSlider:Set(20)

-- Keybind to toggle aimbot (example with RightShift)
local aimbotKey = Enum.KeyCode.RightShift

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if not gameProcessed and input.KeyCode == aimbotKey then
		aimbotEnabled = not aimbotEnabled
		aimbotToggle:Set(aimbotEnabled)
		if aimbotEnabled then
			cameraFollowToggle:Set(false)
		end
	end
end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local localPlayer = Players.LocalPlayer
local camera = workspace.CurrentCamera

-- ==== WalkSpeed Input Logic ====
WalkSpeed_Input.FocusLost:Connect(function(enterPressed)
	local val = tonumber(WalkSpeed_Input.Text)
	if val then
		if val < 8 then val = 8 end
		if val > 500 then val = 500 end
		WalkSpeed_Input.Text = tostring(val)
		local humanoid = localPlayer.Character and localPlayer.Character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			humanoid.WalkSpeed = val
		end
	else
		WalkSpeed_Input.Text = "16"
	end
end)

-- ==== Infinite Jump Logic ====
local infiniteJumpEnabled = false
InfiniteJump_Toggle.OnToggle:Connect(function(state)
	infiniteJumpEnabled = state
end)

UserInputService.JumpRequest:Connect(function()
	if infiniteJumpEnabled then
		local humanoid = localPlayer.Character and localPlayer.Character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
		end
	end
end)

-- ==== Opacity Slider Logic ====
Opacity_Slider.OnValueChanged:Connect(function(value)
	local transparency = 1 - (value / 100)
	MainFrame.BackgroundTransparency = transparency
	for _, child in ipairs(MainFrame:GetChildren()) do
		if child:IsA("Frame") or child:IsA("TextLabel") or child:IsA("TextButton") then
			child.BackgroundTransparency = transparency
		end
	end
end)

-- ==== ESP Logic ====
local espEnabled = false
local teamCheckEnabled = true

ESP_Toggle.OnToggle:Connect(function(state)
	espEnabled = state
	if not espEnabled then
		for _, highlight in ipairs(workspace:GetDescendants()) do
			if highlight.Name == "MyaXESPHighlight" then
				highlight:Destroy()
			end
		end
		RunService:UnbindFromRenderStep("MyaXESP")
	else
		RunService:BindToRenderStep("MyaXESP", 301, function()
			for _, p in ipairs(Players:GetPlayers()) do
				if p ~= localPlayer and p.Character and p.Character:FindFirstChild("HumanoidRootPart") and p.Character:FindFirstChildOfClass("Humanoid") and p.Character.Humanoid.Health > 0 then
					if teamCheckEnabled and p.Team == localPlayer.Team then
						local highlight = p.Character:FindFirstChild("MyaXESPHighlight")
						if highlight then highlight:Destroy() end
					else
						local highlight = p.Character:FindFirstChild("MyaXESPHighlight")
						if not highlight then
							highlight = Instance.new("Highlight")
							highlight.Name = "MyaXESPHighlight"
							highlight.FillColor = Color3.fromRGB(0, 170, 255)
							highlight.OutlineColor = Color3.fromRGB(0, 0, 0)
							highlight.Parent = p.Character
						end
					end
				else
					local highlight = p.Character and p.Character:FindFirstChild("MyaXESPHighlight")
					if highlight then
						highlight:Destroy()
					end
				end
			end
		end)
	end
end)

TeamCheck_Toggle.OnToggle:Connect(function(state)
	teamCheckEnabled = state
	if espEnabled then
		ESP_Toggle.OnToggle:Fire(true) -- refresh ESP highlights
	end
end)

-- ==== Camera Follow & Aimbot Logic ====
local cameraFollowEnabled = false
local aimbotEnabled = false
local predictionEnabled = false

CameraFollow_Toggle.OnToggle:Connect(function(state)
	cameraFollowEnabled = state
	if state then
		Aimbot_Toggle:Set(false)
	else
		camera.CameraType = Enum.CameraType.Custom
	end
end)

Aimbot_Toggle.OnToggle:Connect(function(state)
	aimbotEnabled = state
	if state then
		CameraFollow_Toggle:Set(false)
	else
		camera.CameraType = Enum.CameraType.Custom
	end
end)

Prediction_Toggle.OnToggle:Connect(function(state)
	predictionEnabled = state
end)

local function getTargetPlayer()
	local selectedIndex = PlayerDropdown:Get()
	local players = Players:GetPlayers()
	local validPlayers = {}
	for _, p in ipairs(players) do
		if p ~= localPlayer then
			table.insert(validPlayers, p)
		end
	end
	return validPlayers[selectedIndex] or nil
end

RunService:BindToRenderStep("MyaXCameraFollow", 302, function()
	if cameraFollowEnabled then
		local target = getTargetPlayer()
		if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
			local hrp = target.Character.HumanoidRootPart
			camera.CameraType = Enum.CameraType.Scriptable
			local offset = Vector3.new(0, 5, -10)
			camera.CFrame = CFrame.new(hrp.Position + offset, hrp.Position)
		else
			camera.CameraType = Enum.CameraType.Custom
		end
	else
		camera.CameraType = Enum.CameraType.Custom
	end
end)

RunService:BindToRenderStep("MyaXAimbot", 303, function()
	if aimbotEnabled then
		local target = getTargetPlayer()
		if target and target.Character and target.Character:FindFirstChild("Head") then
			local targetPos = target.Character.Head.Position
			if predictionEnabled then
				local velocity = target.Character:FindFirstChild("HumanoidRootPart") and target.Character.HumanoidRootPart.Velocity or Vector3.new()
				targetPos = targetPos + velocity * 0.1
			end
			camera.CFrame = CFrame.new(camera.CFrame.Position, targetPos)
		end
	end
end)

-- ==== Crosshair Logic ====
local crosshairVisible = true
local crosshairColor = Color3.fromRGB(255, 255, 255)
local crosshairSize = 20

Crosshair_Toggle.OnToggle:Connect(function(state)
	crosshairVisible = state
	CrosshairFrame.Visible = crosshairVisible
end)

CrosshairColor_Dropdown.OnSelectionChanged:Connect(function(index)
	local colors = {
		Color3.fromRGB(255, 255, 255),
		Color3.fromRGB(255, 0, 0),
		Color3.fromRGB(0, 255, 0),
		Color3.fromRGB(0, 0, 255),
	}
	crosshairColor = colors[index] or Color3.fromRGB(255, 255, 255)
	for _, part in pairs(CrosshairFrame:GetChildren()) do
		if part:IsA("Frame") then
			part.BackgroundColor3 = crosshairColor
		end
	end
end)

CrosshairSize_Slider.OnValueChanged:Connect(function(value)
	crosshairSize = value
	CrosshairFrame.Size = UDim2.new(0, crosshairSize, 0, crosshairSize)
	for _, part in pairs(CrosshairFrame:GetChildren()) do
		if part:IsA("Frame") then
			if part.Name == "Left" or part.Name == "Right" then
				part.Size = UDim2.new(0, crosshairSize / 5, 0, 2)
			elseif part.Name == "Top" or part.Name == "Bottom" then
				part.Size = UDim2.new(0, 2, 0, crosshairSize / 5)
			end
		end
	end
end)

-- Initialize crosshair UI defaults
CrosshairColor_Dropdown:Set(1)
CrosshairSize_Slider:Set(20)

-- ==== Keybind for Aimbot Toggle ====
local aimbotKey = Enum.KeyCode.RightShift
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if not gameProcessed and input.KeyCode == aimbotKey then
		aimbotEnabled = not aimbotEnabled
		Aimbot_Toggle:Set(aimbotEnabled)
		if aimbotEnabled then
			CameraFollow_Toggle:Set(false)
		end
	end
end)
